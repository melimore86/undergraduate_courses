---
title: "Creating maps with ggplot2+sf and ggmap"
author: "Melissa Moreno"
date: "May 26, 2017"
output:
  pdf_document:
    toc: yes
    toc_depth: '2'
  html_document:
    fig_caption: no
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
---


```{r global_options, include = FALSE}
knitr::opts_chunk$set(
    results = "hide",
    warning = FALSE, 
    message = FALSE,
    cache = TRUE)
## This is just to "pre-load" all packages, and prevent the startup
## messages to show
library("ggmap")
library("ggplot2")
library("ggthemes")
library("legendMap")
library("maps")
library("maptools")
library("rgdal")
library("rgeos")
library("rworldmap")
library("rworldxtra")
library("rgdal")
library("sf")
library("sp")
library("tidyverse")
library("tools")
library("dplyr")

```


# Introduction


## Beautiful maps in a beautiful world

Maps are used in a variety of fields to express data in an appealing and interpretive image. Data can be expressed into simplified complex patterns, and this data interpretation is generally lost if the data is written out into spread sheets. Maps can add vital context by incorporating many variables into and easy to read and relatble context. Maps are also very important in the information world because they can quickly allow the public to gain better insight so that they can stay informed and make better personal decisions. It's critical to have maps be effective, which means creating maps that can be understood by your target audience. Maps that need to be understood by children would very different from maps intended for geographers. Knowing what elements are required to enhance your data is key into making effective maps. 


Some elements of a map that should be considered are polygon, points, lines, and text. With that in mind, we need to think about what in our map is required to really make an impact on our intended audience. Layout and formatting can also be used to enhance your data visually. It's important to think about the arrangement of these maps elements and how they they will be placed to make a maximum impact on the target audience. Polygons, in  a map, are considered to be shapes in a map such as counties. Lines are considered to be shapes that are not filled with any aspect, such as highways, streams, or roads. Points on a map are used to specify small specific areas such as city locations. 


Using R to create maps is very user friendly. You can add and remove elements on a map with ease. It is also easy to reproduce the same maps for different data sets. It is important to be able to script the elements of a map so that it can used and interpreted by any user. It's relatively easy to e-mail R codes to colleages, so the community aspect of R is very developed. Any code in R can be tweeked to make major enhancements with a stroke of a key. 


Current solutions for creating maps are ArcGIS, QGIS, eSpatial, etc. The reason for using R is because it is a powerful and flexible tool. R can be used from calulating data sets to creating graphs and maps with the same data set. R is also free, which makes it very easily accessible to any one. Some other advantages of using R is that it has an interactive language, data structures, graphics availablity, a developed community, repairing/replacing missing data, and the advantage of adding more tools through packages.  


## A solution using R and its ecosystem of packages

R is a free and open-source software development environment (IDE) that is used for computing statistical data and graphic in a programmable langauge. R requires different packages installed to allow for linear and nonlinear modelling, statistical tests, time series analysis, classification, clustering, etc. CRAN, the comprehensive R archive network, which consists of a network of ftp and web servers that store identical versions of code and documentation for R. R is a scriptable language that allows the user to write out a code in which it will execute the command specified. 

Packages in R create an ecosystem of different data analysis and interpretation. There are packages that are already programmed into a newly installed R, and we will be using several of those packages, as well as some developing packages. 

The package `ggplot2` implements the grammar of graphics in R, as a
way to create code that make sense to the user: The grammar of
graphics is a term used to breaks up graphs into semantic components,
such as geometries and layers. Practically speaking, it allows (and
forces!) the user to focus on graph elements at a higher level of
abstraction, and how the data must be structured to achieve the
expected outcome.

While `ggplot2` is becoming the *de facto* standard for R graphs, it
does not handle spatial data specifically.  The current standard for
spatial objects in R is defined as `Spatial` classes in the package
`sp`, but a new standard following the "simple feature" standard is
currently in development in the package `sf`.  The development version
of the package `ggplot2` now allows the programmer to create layers
using simple features from the package `sf`. The combination of
`ggplot2` and `sf` therefore enable to create maps, using the grammar
of graphics, just as informative or visually appealing as any GIS
software.


## Preparation of R

To download R, you can vist the CRAN website https://www.r-project.org/. You can choose to download R for PC users or Mac. R is a highly recommended program because it is a free open-source software that is constantly updating nd upgrading. 

Packages can be installed with the following code:

```{r, eval = FALSE}
install.packages()
```


<!-- how to install packages, and necessary packages, by alphabetical -->
<!-- order -->

<!-- which ones need to be installed with their dev version using -->
<!-- `devtools::`? -->

Some packages (`legendMap`,) are currently only
available on GitHub, so we use the package `devtools` to install them:

```{r pkg-install, eval = FALSE}
install.packages(c("devtools", "ggmap", "ggplot2", "ggthemes", 
    "maps", "maptools", "rgdal", "rgeos", "rworldmap", "rworldxtra", 
    "sf", "sp", "tidyverse", "tools"))  # Do we need the entire tidyverse?

library("devtools")
install_github("3wen/legendMap")
```

We start by loading the necessary packages for all maps:

```{r pkg-ggplot2-sf}
library("ggplot2")
library("sf")
library("sp")
```


# General concepts illustrated with the World Map


## Data and basic plot (`ggplot` and `geom_sf`)

First let us start with creating a base map of the world using
`ggplot`. This base map will then be extended with different
geographic or graph elements, as well as zoomed in to an area of
interest.

The package `rworldmap` provides a map of countries of the entire
world; a map with higher resolution is available in the package
`rworldxtra`. We use the function `getMap` to extract the world map
(the resolution can be set to `"low"`, if preferred):

```{r pkg-rworldmap}
library("rworldmap")
library("rworldxtra")
```
```{r world}
world <- getMap(resolution = "high")
class(world)
```

The world map is available as a `SpatialPolygonsDataFrame`; we thus
convert it to a simple feature using `st_as_sf` (from package `sf`):

```{r world-sf}
world <- st_as_sf(world)
class(world)
```

We can check that the map was properly retrieved and converted into an
`sf` object, and plot it:

```{r world-plot}
ggplot(data = world) +
    geom_sf()
```

This call nicely introduces the structure of a `ggplot` call: The
first part `ggplot(data = world)` initiates the `ggplot` graph, and
indicates that the main data is stored in the `world` object. The line
ends up with a `+` sign, which indicate that the call is not complete
yet, and each subsequent line correspond to another layer or scale. In
this case, we use the `geom_sf` function, which simply add a geometry
stored in a `sf` object. By default, all geometry functions use the
main data set up in `ggplot()`, but we will see later how to provide
additional data.

Note that layers are added one at a time in a `ggplot` call, so the
order of each layer is very important. All data will have to be in an
`sf` format to be used by `ggplot2`,and will be converted from `sp` to
`sf` if necessary.

## Titles and Subtitles (`ggtitle`)

We can add a title and subtitle to our map using the command
`ggtitle`. Make sure you add the quotation marks around your title and
subtitle names:
   
```{r world-title}
ggplot(data = world) +
    geom_sf() +
    ggtitle("World map", subtitle = paste0("(", length(unique(world$NAME)), " countries)"))
```


## Axis Titles (`xlab`/`ylab`)

We can change the axis names to something more suitable. Depending on what your map diplays, axis labels could be different.

```{r world-axis}
ggplot(data = world) +
    geom_sf() +
    xlab("Longitude") + ylab("Latitude")
```


## Map Color (`geom_sf`)

In this example, we will be filling the polygons of the countries
with a green color (argument `fill`), and using black for the outline
of the countries (argument `color`):

```{r world-colors}
ggplot(data = world) + 
    geom_sf(color = "black", fill = "lightgreen")
```

`ggplot2` allows the use of more complex color schemes, such as a
gradient on one variable of the data. Let us see how to use the
population of each country (variable `POP_EST` of the `world` object)
here:

```{r world-colors-pop, eval = FALSE}
ggplot(data = world) +
    geom_sf(aes(fill=POP_EST))              
```


## Zoom in (`coord_sf`)

We can set the coordinates of the map to "zoom" in the area we are
interested in mapping. To do this, we use `coord_sf` to create our
coordinate settings, with limits on the x-axis (`xlim`), and on the
y-axis (`ylim`). Note that the limits are automatically expanded by a
fraction, so that selected data and axes don't overlap. It is possible
to set the zoom to the exact limits provided with `expand = FALSE`).

```{r world-zoom}
ggplot(data = world) +
    geom_sf() +
    coord_sf(xlim = c(-102.15, -74.12), ylim = c(7.65, 33.97))
```


## Scale Bar and North Arrow

Many packages are available to create a scale bar on a map
(e.g. `prettymapr` or `vcd`"). The
package `legendMap` provides an easy-to-use function that allows to
add simultaneously the north symbol and a scale bar into the `ggplot`
map:

```{r pkg-legendMap}
library("legendMap")
```

Five arguments need to be set manually: `lon`, `lat`, `distance_lon`,
`distance_lat`, and `distance_legend`. The location of the scale bar
has to be specified in longitude/latitude in the `lon` and `lat`
arguments. The shaded distance inside the scale bar is controlled by
the `distance_lon` argument. 
<!-- Can you have one with an alternation of black and white segments? -->
In our case, 500 km is a good distance to use.
<!-- describe `distance_lat` and `distance_legend` -->

Additionally, it is possible to change the font size for the legend of
the scale bar (argument `legend_size`, which defaults to 3). The North
arrow behind the "N" north symbol can also be adjusted for its length
(`arrow_length`), its distance to the scale (`arrow_distance`), or the
size the N north symbol itself (`arrow_north_size`, which defaults to
6).

Note that all distances (`distance_lon`, `distance_lat`,
`distance_legend`, `arrow_length`, `arrow_distance`) are set to `"km"`
by default in `distance_unit`; they can also be set to nautical miles
with "nm", or miles with "mi".


```{r world-scalebar}
ggplot(data = world) +
    geom_sf() +
    coord_sf(xlim = c(-102.15, -74.12), ylim = c(7.65, 33.97)) +
    scale_bar(lon = -99.66, lat = 8, distance_lon = 500,
        distance_lat = 50, distance_legend = 100, arrow_length = 300,
        arrow_north_size = 10)
```


## Country Names

The `world` data set already contains country names and the
coordinates of the centroid of each country (among more
information). We can use this information to plot country names, using
`world` as a regular `data.frame` in `ggplot2`. We first check the
country name information:

```{r world-names}
head(world[, c("NAME", "LON", "LAT")])
```

The command `geom_text` can be used to add a layer of text to a
graphic. The command `geom_text` requires the data needed to enter the
country names, which is the same data as the world map. We can adjust
the size (argument `size`). By default, the text is centered on the
coordinates provided; we can adjust the alignment horizontally or
vertically using the arguments `hjust` and `vjust`, which can either
be a number between 0 (right/bottom) and 1 (top/left) or a character
("left", "middle", "right", "bottom", "center", "top"), or we can
offset the text horizontally or vertically with the argument `nudge_x`
and `nudge_y`.

We can also adjust the font of the text, for instance its color
(argument `colour`) or the type of font (`fontface`, which was set to
`"bold"`). Finally, the argument `check_overlap` remove country names
that are overlapping each other.

```{r world_countrylabel}
ggplot(data = world) +
    geom_sf() +
    coord_sf(xlim = c(-102.15, -74.12), ylim = c(7.65, 33.97)) +
    geom_text(aes(LON, LAT, label = NAME), size = 4, hjust = "left",
        colour = "black", fontface = "bold", check_overlap = TRUE)
```


## Themes and Final Map

Now to make the final touches. We want to edit the theme of the map to
make it more appealing. We added `theme_classic` for a standard theme,
but there are many other themes that can be selected from. You can
experiment adding and removing themes to see which one best suits your
map. The argument `legend.position`, wasn't use since we don't require
a legend in our map. Otherwise, such variables such as `topright` or
`bottomleft` might be used. The `panel.grid.major` will allow us to
edit the grid lines in the map. We chose a gray color, with a line
type of dashed to break up the map borders from the grid lines. We
wanted to add some color to the map backgraound, which is the ocean
essentially, so we changed that with `panel.background`. We really
wanted a border around the map, so the `panel.border` argument was
used to add one . It will take some time to see elements of the theme
need to be changed or added to best meet your map needs. There are
many more aesthetics can be added to your custom theme, and they are
all listed in the ggplot2 pdf in Helpful Resources.

```{r world-florida-final}
ggplot(data = world) +
    geom_sf(fill = "lightgreen") +
    coord_sf(xlim = c(-102.15, -74.12), ylim = c(7.65, 33.97)) +
    ggtitle ("World map centered on Florida") +
    scale_bar(lon = -99.66, lat = 8, distance_lon = 500,
        distance_lat = 50, distance_legend = 100, arrow_length = 300,
        arrow_north_size = 10) +
    xlab("Longitude") + ylab("Latitude") +
    geom_text(aes(LON, LAT, label = NAME), size = 4, hjust = "left",
        colour = "black", fontface = "bold", check_overlap = TRUE) +
    theme_classic() +
    theme(panel.grid.major = element_line(colour = gray(.5),
        linetype = "dashed", size = 0.5),
        panel.background = element_rect(fill = "lightblue"),
        panel.border = element_rect(fill = NA))
```


# Additional layers with polygons, points,lines, and text


## Introduction

In the previous section, we presented general concepts with a map with
little information (country borders). The modular approach of
`ggplot2` allows to add additional layers in subsequent additions of
`geom_sf`, for instance water bodies or terrain features, as will be
illustrated in this section.

In order to present fully reproducible examples, we will be using the
environmental layers found
on
[MapCruzin.com](http://www.mapcruzin.com/free-united-states-shapefiles/free-florida-arcgis-maps-shapefiles.htm). Following
the link, data packages derived
from [OpenStreetMap.org](http://www.openstreetmap.org/) can be freely
downloaded and used under
the
[Open Data Commons Open Database License](http://opendatacommons.org/licenses/odbl/) (ODbL).


## Point coordinates (`geom_point`)

We start by defining two study sites, according to their longitude and
latitude. The information is stored in a `data.frame`, with two
variables `longitude` and `latitude`:

```{r points-sites}
(sites <- data.frame(longitude = c(-80.144, -80.109), latitude = c(26.479, 26.830)))
```

The easiest way to add point coordinates is with the general-purpose
function `geom_point`, which works on any X/Y coordinates,
of regular data points (i.e. not geographic). As such, we can adjust
all characteristics of points (e.g. color of the outline and the
filling, shape, size, etc.), for all points, or using grouping from
the data (i.e defining their "aesthetics"). In this example, we add
the two points as diamonds (`shape = 23`), filled in dark red (`fill =
"darkred"`) and of bigger size (`size = 6`):

```{r points-plot}
ggplot(data = world) +
  geom_sf() +
  coord_sf(xlim = c(-89.15, -76.12), ylim = c(24.65, 33.97)) +
  geom_point(data = sites, aes(x = longitude, y = longitude), size = 6, shape = 23, fill = "darkred")
```

All of this can also be achieved with `sf`, using `POINT` geometries 
<!-- To be extended a bit -->

```{r points-sf}
(sites <- st_as_sf(sites, coords = c("longitude", "latitude"), crs = 4326))

ggplot(data = world) +
  geom_sf() +
  geom_sf(data = sites, size = 2, shape = 20, fill = "darkred") + # Bug with 'shape'… I think it requires dev version of ggplot2
  coord_sf(xlim = c(-89.15, -76.12), ylim = c(24.65, 33.97))
```


## State and County map/name data

Very similar to the previous map, we first need to retrieve a map from the package `rworldmap` and `rworldxtra`. As you have already figured out, we normally start with a very broad map, and then narrow it down to what we are interested in showing. 

```{r coor_getMap}
worldmap <- getMap(resolution = "high")
map1 <- sf::st_as_sf(worldmap)          # We already have it in 'world'!
```

In this map with coordinate points we require more detail, since the
map will have no landscape features…

<!-- I stopped here. This uses a data frame, and no spatial object (sp or -->
<!-- sf). I couldn't find an easy way to convert this map to a sp/sf -->
<!-- object. Can we maybe use data from here: -->
<!-- http://gadm.org/ -->
<!-- There are available as R objects directly, and provide all information -->
<!-- you need: -->

```{r usa-data}
#download.file("http://biogeo.ucdavis.edu/data/gadm2.8/rds/USA_adm0.rds", "USA_adm0.rds")
#usa <- st_as_sf(readRDS("USA_adm0.rds"))
#download.file("http://biogeo.ucdavis.edu/data/gadm2.8/rds/USA_adm1.rds", "USA_adm1.rds")
#usa.s <- st_as_sf(readRDS("USA_adm1.rds"))
#download.file("http://biogeo.ucdavis.edu/data/gadm2.8/rds/USA_adm2.rds", "USA_adm2.rds")
#usa.c <- st_as_sf(readRDS("USA_adm2.rds"))
#file.remove("USA_adm0.rds", "USA_adm1.rds", "USA_adm2.rds")

#usa.s_centroids <- st_centroid(usa.s)   # To add names at state
                                        # centroids (can do the same
                                        # for counties)
## We can ignore the warning here.

#ggplot(data = usa.s) +
   # geom_sf() +
    #geom_sf(usa.s_centroids, size = 6)
```



In this example, we will add US state
borders and names for detail. Now that we have the state border outlines, we
want to check the headings. Before we needed the lon and lat to
display our points, lets see if its the same in this case. You can
observe that the headings are long and lat. Entering the correct x and
y-axis names will ensure our state borders will display properly.

```{r coord_getState}
states <- map_data("state")
head(states)
```

We can retrieve the state names with the same map data we just collected. In our case, we would like the state names to be in the middle of each state polygon. We will use an aggregate command to do this. We combine the longitude and latitude, with the state region in the data set. We will set the function to use the mean and range to place the state names in the middle of the state. 


```{r coordmap_statenames}
cnames <- aggregate(cbind(long, lat) ~ region, data=states, 
          FUN=function(x)mean(range(x)))
```

We noticed that these state names were not capitalized, so we will go ahead and make that adjustment. The names can be capitalized using the package `tools`. 

```{r coordmap_capitalizing}
library("tools")
cnames$region <- toTitleCase(cnames$region)
stringr::str_to_title("Me and my girl friend")
```

  
We would like even more detail for the map, so we will add county lines. Depending on what you want to display on your map, you might not want to display county outlines. Once again we will check the headings of the county lines to make sure they are the same headings as the state borders. 


```{r coord_getCounty}
counties <- map_data("county")
head(counties)

```



## Plotting County Lines


Now that we have the area we are interested in, we can add the county lines we retrieved earlier. The county lines can be modified for different line widths and colors. In this case we used dark green to make the county lines different from the state borders. We use the code `geom_polygon` to add the polygon lines of the county borders. We previously tried with `geom_lines`, but it was not succesful in creating the county outlines. Once again, the command requires the data for the layer. You can then choose the fill color for the inside of the polygon, and the color of the actual lines of the counties. It can be useful to fill in the counties with varying color, if you think it will add more aethetics to your map. Now the aes() argument reqiures the x and y coordinates of the counties layer. We are also inheriting the previous code aethetics into this layer with inherit.aes=. 

```{r coord_countieslines}
ggplot() +
  geom_sf(data=world) +
  coord_sf(xlim = c(-89.15, -76.12), ylim = c(24.65, 33.97), expand=TRUE ) +
  geom_polygon(data=counties, fill= NA, colour= "darkgreen", aes(x=long, y=lat, group=group),inherit.aes=TRUE)
```

## Plotting State Borders/Names

To continue adding to our map, we will be adding the state borders. We are using the same `geom_polygon` command, and the arguments used are the same as for county lines. The difference would be to make the color of the outline black, to really stand out, and to make the size thickness of the line slightly thicker than the county lines. We did not need to add a legend with aspects of the states, so we do not have arguments such as `color` or `fill` to draw the variables form. 

For text on our map, we will be using `geom_text`. This function allow us to add any text we desire on our map. It can be used in varius different ways that will be show on other maps as well. Our long and lat is specified in the data, and we use region as our state labels. We then specidied the size, is we wanted to inherit the previous aesthetics, the color, if wanted the program to check for overlapping names, if we wanted our text bold, and how we looked like the names to be nudged. 
 

```{r coordmap_stateborder}
ggplot() +
  geom_sf(data=world) +
  coord_sf(xlim = c(-89.15, -76.12), ylim = c(24.65, 33.97), expand=TRUE) +
  geom_polygon(data=states, fill= NA, colour= "black", aes(x=long, y=lat, group=group),inherit.aes=TRUE, size=.76) +
  geom_text(aes(long, lat, label = region), data = cnames, size = 4.2, inherit.aes = TRUE, col = "grey18", check_overlap = TRUE, fontface="bold", nudge_x=.25, nudge_y=.35)
```



## Themes and Final Map


Because our code is the same for title and subtitles, scale bar and north symbol, and axis titles we will not repeat the steps for this map. Please refer back to those topics if you are unsure how to create/edit those features. For this map we will remove the axis titles since we will not be using coordinate units. 

Now to make the final touches. We want to edit the theme of the map to make it more appealing. We added `theme_map`, for a standard theme, but there are many other themes that can be selected from. This theme removes the longitude and latitude lines around the map border. Please refure back to the World Map Themes and Final Map for a description of each argument. 

```{r coormap_final}
#library(ggthemes)

ggplot() +
  geom_sf(data=world, fill= "lightgreen")+coord_sf(xlim = c(-89.15, -76.12), ylim = c(24.65, 33.97), expand=TRUE ) +
  geom_polygon(data=counties, fill= NA, colour= "darkgreen", aes(x=long, y=lat, group=group),inherit.aes=TRUE) +
  geom_polygon(data=states, fill= NA, colour= "black", aes(x=long, y=lat, group=group),inherit.aes=TRUE, size=.76) +
  geom_text(aes(long, lat, label = region), data = cnames, size = 4.2, inherit.aes = TRUE, col = "grey18", check_overlap = TRUE, fontface="bold", nudge_x=.25, nudge_y=.35) +
  geom_point(data = sites, aes(x = longitude, y = latitude, fill = "darkred"), size = 3, shape = 21) +
  ggtitle ("Stork Observation Sites", subtitle = "2017") +
  scale_bar(lon = -88.66, lat =25,distance_lon = 150, distance_lat = 25, distance_legend = 100, dist_unit = "km",             arrow_length=75, arrow_distance=150, arrow_north_size =6, orientation= TRUE,legend_size=2) + 
  theme_map() + 
  theme(legend.position = "none", panel.grid.major = element_line(colour = gray(.5), linetype = "dashed", size = 0.5),        panel.background = element_rect(fill = "lightblue"), panel.border=element_rect(fill=NA))

```

## Final  Notes

You should realize by now that adding layers on `ggplot` is relatively easy, as long as your data is configured correctly, and your arguments are valid. Depending on what you need for your own maps, you might need or not need some of those commands. You can create more than two points on any given map simply by adding another variable with coordinates. 




# Plotting layers, and additional features

##Introduction

In our other maps, we were creating general map with very little landscape information. Some maps will require water or terrain features to enhance your information. We will be using the shapefiles found in this link http://www.mapcruzin.com/free-united-states-shapefiles/free-florida-arcgis-maps-shapefiles.htm, so you can follow along. You can download some of the packages and unzip them to create the layers on the next map.

Sometimes, however, you will provided better or more accurate data, but we will use this public shapefile data to become familiar with adding layer shapefile.

The packages used for this map are listed for convience. 


```{r featmap_packages}
library(sp)
library(sf)
library(ggplot2)
library(rgdal)
library(rgeos)
library(maps)
library(maptools)
library(rworldmap)
library(rworldxtra)
library(devtools)
library(legendMap)
library(tidyverse)
library(ggmap)
```

## Data and basic plot

We need the package `rgdal` to allow us to read the shapefile from the folders.  

Credit to OpenStreetMap.org and MapCruzin.com.


```{r featmap_data}

#library(rgdal)

#https://stackoverflow.com/questions/12855194/download-and-unzip-shapefile-to-temporary-directory

flstparks<-readOGR(dsn="E:/Basille Lab/LayersShapefiles/stpark_dec15",layer="stpark_dec15")

flmjwater<-readOGR(dsn="E:/Basille Lab/LayersShapefiles/mjwaterbnd",layer="mjwaterbnd")


flparksandrec<-readOGR(dsn="E:/Basille Lab/LayersShapefiles/gc_parksbnd_jul16",layer="gc_parksbnd_jul16")

flhighway<-readOGR(dsn="E:/Basille Lab/LayersShapefiles/interstates",layer="interstates")
```


To make sure our layers are compatible we will be tranforming every layer into the EPSG 4326, which is datum WGS 84. Our layers will then will be projected accurately on our map. There is no need to convert these shapefiles into an `sf` format, because they are data frames that can be read by `ggplot`. 


```{r featmap_transform}
flstparks2<-spTransform(flstparks, CRS("+init=epsg:4326"))

flmjwater2<-spTransform(flmjwater, CRS("+init=epsg:4326"))

flparksandrec2<-spTransform(flparksandrec, CRS("+init=epsg:4326"))

flhighway2<-spTransform(flhighway, CRS("+init=epsg:4326"))
```


Just like before, we will retrive the world data from getMap under the `rworld` package and the resolution from the `rworldxtra`.  

```{r featmap_world}
#library(rworldmap)
#library(rworldxtra)

worldmap <- getMap(resolution = "high")

map1<- sf::st_as_sf(worldmap )

states <- map_data("state")
```


## Creating Cities 

We would like to add the main Florida cities to our map, as opposed to all of the cities. You can use this general code for any city in the United States. You could change the region to the state name, which is lowercase. The frunction `geocode` requires the package `ggmap` to work.

```{r featmap_cities}
#library(ggmap)

FL<- map_data("state", region="florida")

flcities <- data.frame(State=rep("florida",7), 
                         City=c("Miami", "Fort Lauderdale", "Orlando", "Gainesville", "Tallahassee", "Tampa","Jacksonville"))

flcities<-cbind(geocode(as.character(flcities$City)),flcities)
```



## Map with layers

We will now be adding shapefile layers unto our basic map.

```{r}
  ggplot()+
  geom_sf(data=map1, fill="antiquewhite1") +
  coord_sf(xlim = c(-87.35, -79.50), ylim = c(24.10, 30.80), expand=TRUE )
    
```



## Plotting Polygons

Since we will not be using `color` or `fill` in our map to make a legend, we will put that aethetic information outside of the `aes()`. For polygon plotting, the correct class of shapefile needs to be used. You can use the class() to determine if your shapefile is a `SpatialPolygonDataFrame`. After determining what kind of spatial data frame is being used, you can start coding the `geom_polygon`. The reason `sf` is so valuable, is that it will take the geometry coodrinates in the spatial data frame and plot them. You can see the geometery coordinates using head(). In our map code, there are many examples on how the `geom_polygon` can  be written. However, there are requirements needed for the function to work. The data set needed is required for `geom_polygon` as well as the aesthetics, `aes()`. Just as mentioned before, fill is used to fill in the polygon with a color, and color is used for the outline of the polygon. Since we will not be using those values in a legend, it is outside of the `aes()`. Inside the `aes()` are our coordinates units and x and y, as well as our group, which in our case is generic, `group=group`. 

```{r featmap_poly}
  ggplot()+
  geom_sf(data=map1, fill="antiquewhite1") +
  coord_sf(xlim = c(-87.35, -79.50), ylim = c(24.10, 30.80), expand=TRUE ) +
  geom_polygon(data=flstparks2,colour= "forestgreen",fill="forestgreen", aes(x= long, y=lat, group=group),inherit.aes=TRUE) +
geom_polygon(data=flparksandrec, fill= "darkgreen", colour= "darkgreen", aes(x= long, y=lat, group=group),inherit.aes=TRUE, alpha=0.8) +
  geom_polygon(data=flmjwater2, fill= "deepskyblue", colour= "deepskyblue", aes(x= long, y=lat, group=group),inherit.aes=TRUE, alpha=0.8) +
  geom_polygon(data=states, fill= NA, colour= "black", aes(x=long, y=lat, group=group),inherit.aes=TRUE, size=.8) 
```


## Plotting Paths 

Most would think that `geom_line` is what would be needed to create the line shapes in the map, but the correct function would be `geom_path`. Because we transformed our flhighways file to datum WGS84, the coordinates in the spatial lines data frame could be read and displayed correctly. If `geom_lines` is used instead, the lines will become distorted and will create extra lines to fill in a polygon shape. 

```{r featmap_path}
  ggplot()+
  geom_sf(data=map1, fill="antiquewhite1") +
  coord_sf(xlim = c(-87.35, -79.50), ylim = c(24.10, 30.80), expand=TRUE ) +
  geom_path(data=flhighway2, aes(x=long, y=lat, group=group),inherit.aes=TRUE, col="black", size=.65) 


```


## Annotated text

We used previously `geom_text` to add the state names in the Coordinates Points Map, but we can also use `annotate` to manually add text to our map. In this case we will be adding a text for the Gulf of Mexico. We specify that we will be using a geom_text in the `geom=` argument. We will also specify where we would like the text on the map using the x and y. Our label is the actual text `Gulf of Mexico`. We also can describe the color and the sizez of the text. 

```{r featmap_annotext}

  ggplot()+
  
  geom_sf(data=map1, fill="antiquewhite1") +
  
  coord_sf(xlim = c(-87.35, -79.50), ylim = c(24.10, 30.80), expand=TRUE ) +
  
annotate(geom="text", x=-85.50, y=27.00, label= "Gulf of Mexico", color="grey22",size=4.5) 

```





## Final Map

The final map will include very familiar themes and features. Some instances you will see `color`, `colour`, and `col` being used, but they all mean the same code. You can use `col` and it will apply the same effect as `color`. 


```{r featmap_final}
  ggplot()+
  geom_sf(data=map1, fill="antiquewhite1") +
  coord_sf(xlim = c(-87.35, -79.50), ylim = c(24.10, 30.80), expand=TRUE ) +
  geom_polygon(data=flstparks2,colour= "forestgreen",fill="forestgreen", aes(x= long, y=lat, group=group),inherit.aes=TRUE) +
  geom_polygon(data=flparksandrec2, fill= "darkgreen", colour= "darkgreen", aes(x= long, y=lat, group=group),inherit.aes=TRUE, alpha=0.8) +
  geom_polygon(data=states, fill= NA, colour= "black", aes(x=long, y=lat, group=group),inherit.aes=TRUE, size=.8) +
  geom_polygon(data=flmjwater2, fill= "deepskyblue", colour= "deepskyblue", aes(x= long, y=lat, group=group),inherit.aes=TRUE, alpha=0.8) +
  geom_path(data=flhighway2, aes(x=long, y=lat, group=group),inherit.aes=TRUE, col="black", size=.65) +
  annotate(geom="text", x=-85.50, y=27.00, label= "Gulf of Mexico", color="grey22",size=4.5) +
  ggtitle ("Florida Natural Resources Map") + 
  xlab("Longitude")+ ylab("Latitude") +
  theme_classic() + 
  theme(legend.position = "none", panel.grid.major = element_line(colour = gray(.5), linetype = "dashed", size = 0.5),panel.background = element_rect(fill = "aliceblue"), panel.border=element_rect(fill=NA)) +
  scale_bar(lon = -87.00, lat =24.50,distance_lon = 100, distance_lat = 15, distance_legend = 50, dist_unit = "km", arrow_length=50, arrow_distance=65, arrow_north_size =5, orientation= TRUE,legend_size=2.5) 
  
```


## Saving with ggsave

Now that you have finished your map, it would be a good idea to save it. Using `ggsave` will allow a graphic to be saved at any time during the map editing. Some compatible map types are 

```{r featmap_ggsave, eval=FALSE}
 ggsave("Floridamap.png", plot = last_plot(), device = "png", path = NULL,
         scale = 1, width = 7, height = 7,
         dpi = 300)
```

# Print Feature

You can use the print function to place multiple maps in one map graphic. This can be a useful and easy way to enchance the information you need to display.  


```{r printmap_mapsdata, include=FALSE}


  rmarkplot<-
  
  ggplot() +
  
  geom_sf(data=map1, fill="antiquewhite1") +
  
  coord_sf(xlim = c(-87.35, -78.97), ylim = c(23.81, 31.00), expand=TRUE ) +
  
  geom_polygon(data=flstparks2,colour= "forestgreen",fill="forestgreen", aes(x= long, y=lat, group=group),inherit.aes=TRUE) +

  geom_polygon(data=flparksandrec2, fill= "darkgreen", colour= "darkgreen", aes(x= long, y=lat, group=group),inherit.aes=TRUE, alpha=0.5) +
  
  geom_polygon(data=states, fill= NA, colour= "black", aes(x=long, y=lat, group=group),inherit.aes=TRUE, size=.76) +
    
  geom_polygon(data=flmjwater2, fill= "deepskyblue", colour= "deepskyblue", aes(x= long, y=lat, group=group),inherit.aes=TRUE, alpha=0.8) +
  
  geom_path(data=flhighway2, aes(x=long, y=lat, group=group),inherit.aes=TRUE, col="gray54", size=.35) +
  
  ggtitle ("Florida Natural Resources Map") + 
  
  xlab("Longitude")+ ylab("Latitude") +
    
  theme_classic() + 
  
  theme(legend.position = "none", panel.grid.major = element_line(colour = gray(.5), linetype = "dashed", size = 0.5),panel.background = element_rect(fill = "aliceblue"), panel.border=element_rect(fill=NA))



rmarkplot2<-  
  
  ggplot() +
  
  geom_sf(data=map1, fill="antiquewhite1") +
  
 coord_sf(xlim = c(-80.30, -80.00 ), ylim = c(26.63, 26.9), expand=TRUE ) +
  
  geom_polygon(data=flstparks2,colour= "forestgreen",fill="forestgreen", aes(x= long, y=lat, group=group),inherit.aes=TRUE) +

  geom_polygon(data=flparksandrec2, fill= "darkgreen", colour= "darkgreen", aes(x= long, y=lat, group=group),inherit.aes=TRUE, alpha=0.5) +
  
  geom_polygon(data=states, fill= NA, colour= "black", aes(x=long, y=lat, group=group),inherit.aes=TRUE, size=.76) +
    
  geom_polygon(data=flmjwater2, fill= "deepskyblue", colour= "deepskyblue", aes(x= long, y=lat, group=group),inherit.aes=TRUE, alpha=0.8) +
  
  geom_path(data=flhighway2, aes(x=long, y=lat, group=group),inherit.aes=TRUE, col="gray54", size=.35) +
  
annotate(geom="text", x=-85.50, y=27.00, label= "Gulf of Mexico", color="grey22",size=4.5) +
    ggtitle ("Location A") + 
  
  xlab("Longitude")+ ylab("Latitude") +
    
  theme_map() + 
  
  theme(legend.position = "none", panel.grid.major = element_line(colour = gray(.5), linetype = "dashed", size = 0.5),panel.background = element_rect(fill = "aliceblue"), panel.border=element_rect(fill=NA),text=element_text(size=6)) 

rmarkplot3<- 
  ggplot()+
  
  geom_sf(data=map1, fill="antiquewhite1") +
  
  coord_sf(xlim = c(-80.30, -80.00 ), ylim = c(26.62, 26.35), expand=TRUE ) +
  
  geom_polygon(data=flstparks2,colour= "forestgreen",fill="forestgreen", aes(x= long, y=lat, group=group),inherit.aes=TRUE) +

  geom_polygon(data=flparksandrec2, fill= "darkgreen", colour= "darkgreen", aes(x= long, y=lat, group=group),inherit.aes=TRUE, alpha=0.5) +
  
  geom_polygon(data=states, fill= NA, colour= "black", aes(x=long, y=lat, group=group),inherit.aes=TRUE, size=.76) +
    
  geom_polygon(data=flmjwater2, fill= "deepskyblue", colour= "deepskyblue", aes(x= long, y=lat, group=group),inherit.aes=TRUE, alpha=0.8) +
  
  geom_path(data=flhighway2, aes(x=long, y=lat, group=group),inherit.aes=TRUE, col="gray54", size=.35) +
  
annotate(geom="text", x=-85.50, y=27.00, label= "Gulf of Mexico", color="grey22",size=4.5) +
  
  ggtitle ("Location B") + 
  
  xlab("Longitude")+ ylab("Latitude") +
    
  theme_map() + 
  
  theme(legend.position = "none", panel.grid.major = element_line(colour = gray(.5), linetype = "dashed", size = 0.5),panel.background = element_rect(fill = "aliceblue"), panel.border=element_rect(fill=NA),text=element_text(size=6))
  
  

```


To use the print function you would need to first make view port that specifiy the max width and height of each map, and the minimum x and y coordinates where it map can be located. The `just=` will make a position on how the secondary maps will be displayed. I wanted the secondary maps to be displayed on the bottom left of the frame, so that will create a guide on where they will first appear. 

```{r printmap_vp}
vp <- viewport(width = 0.37, height = 0.32, x = 0.22, y =0.45, just = c("left","bottom")) 
vp1<- viewport(width = 0.37, height = 0.32, x = 0.22, y =0.15, just = c("left","bottom")) 
```

When the maps are completed, and the viewports are specified, you can now print the secondary maps on top of your main map. This will take some tweeking, since it's not measured in coordinates but rather with R Studios own measurements. 

```{r printmap_finalmap}

print(rmarkplot)
print(rmarkplot2, vp=vp)
print(rmarkplot3, vp=vp1)


```


You can also decide to save this printed map by running all the code at once. It will save it in the format you prefer. We used it as a png. but pdf. is also available. 

```{r printmap_saving, eval=FALSE}
png("PrintMapping.png",width = 7, height = 7, units = "in", res = 300)
print(rmarkplot)
print(rmarkplot2, vp=vp)
print(rmarkplot3, vp=vp1)
dev.off()
```


# Multiple Maps in one window

## Introduction

Having a way to emphasize locations on a map can also be a graphic that would be useful for biologists. The next steps will be to create blank sqaure plots that will make your map visualization interesting and accurate. In our map, we will zooming into two different locations in Florida, for a close up of the area using the map we previously built. 

First we will start with the overall packages needed to build this 

Credit to Ilya Kashnitsky (https://ikashnitsky.github.io/2017/align-six-maps/).

```{r}
library(sp)
library(sf)
library(ggplot2)
library(cowplot)
library(ggthemes)
library(gridExtra)
library(grid)
library(lattice)
library(tidyverse)
```

## Listing the 

```{r}
list.plots=list(rmarkplot,rmarkplot2, rmarkplot3)
```

## Map Placement Function 
 The function for this 

```{r}
align_three_plots <- function(list.plots, family = "")

  {
  
gg <- ggplot()+
 
   coord_equal(xlim = c(0, 80), ylim = c(0, 51), expand=TRUE) +
  
  annotation_custom(ggplotGrob(rmarkplot), xmin = 0.0, xmax =57, ymin = 0.0, ymax = 50) +
  
  annotation_custom(ggplotGrob(rmarkplot2),xmin = 58, xmax = 80, ymin = 25, ymax = 51) +
  
  annotation_custom(ggplotGrob(rmarkplot3), xmin = 58, xmax = 80, ymin = 0.0, ymax = 29) +
  
  labs(x = NULL, y = NULL) +
 
  theme_void()



#DF with the coordinates of the 2 arrows
df.arrows <- data.frame(id=1:2,
                        x=c(45.6,45.4),
                        y=c(21.7,19.8),
                        xend=c(58,58),
                        yend=c(35,12))


gg <- gg +
  geom_segment(data = df.arrows %>% filter(id==1),
             aes(x=x,y=y,xend=xend,yend=yend),
             arrow = arrow(type="closed",length = unit(0.25,"cm"))) +
  geom_segment(data = df.arrows %>% filter(id==2),
             aes(x=x,y=y,xend=xend,yend=yend),
             arrow = arrow(type="closed",length = unit(0.25,"cm")))

# add labes
#gg <- gg + annotate('text',label = labels,
#                    x=c(.5,12.5)+.5,
#                    y=c(29,27.5)+.1,
#                    size=labels.size,hjust=0, vjust=0, #family = family)

#return(gg)

}

```


## Creating a Simple Empty Sqaure Plot

```{r}

library(ggthemes)

p <- 
  ggplot()+
  theme_map() +
  theme(panel.border = element_rect(color = "black", size = 0.5, fill = NA),aspect.ratio = 1)

```

## Cloning and Final Map 

```{r}

#plots <- mget(rep("p", 3))

#three<- align_three_plots(plots)

#plot(three)
```











# Helpful Resources 

##PDFs for packages

-ggplot2 
https://cran.r-project.org/web/packages/ggplot2/ggplot2.pdf
http://ggplot2.tidyverse.org/reference/stat_ecdf.html

-sf
https://cran.r-project.org/web/packages/sf/sf.pdf

-sp
https://cran.r-project.org/web/packages/sp/sp.pdf

-CRAN
https://cran.r-project.org/


##Links and various tutorials

-Global Choropleth, world interactive, rotating map

http://ellisp.github.io/blog/2017/06/04/military-gdp


-Ggplotly

http://www.alexejgossmann.com/salaries_by_school_plotly_viz/


-R studio colors

http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf


-Plotting side by side

https://ikashnitsky.github.io/2017/align-six-maps/


-Leaflet

https://cengel.github.io/rspatial/4_Mapping.nb.html

Points with gganimate
http://blog.cultureofinsight.com/2017/06/building-dot-density-maps-with-uk-census-data-in-r/


-Symobls and Points
http://www.sthda.com/english/wiki/r-plot-pch-symbols-the-different-point-shapes-available-in-r


-Themes
http://ggplot2.tidyverse.org/reference/theme.html


-Two graphs with same legend

https://github.com/tidyverse/ggplot2/wiki/share-a-legend-between-two-ggplot2-graphs

